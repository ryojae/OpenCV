# -*- coding: utf-8 -*-
"""opencv강좌_06.ipynb의 사본

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lsGeSK1I72zH--BQez6L4G7VHNMYtW22
"""

import cv2
cv2.__version__

from google.colab.patches import cv2_imshow

!git clone https://github.com/dltpdn/insightbook.opencv_project_python

"""#6장 영상 필터"""

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/insightbook.opencv_project_python/06.filter

"""##6.1 컨볼루션과 블러링

### 6.1.1 필터와 컨볼루션

### 6.1.2 평균 블러링
"""

!python blur_avg_kernel.py

import cv2
import numpy as np

img = cv2.imread('../img/girl.jpg')
'''
#5x5 평균 필터 커널 생성    ---①
kernel = np.array([[0.04, 0.04, 0.04, 0.04, 0.04],
                   [0.04, 0.04, 0.04, 0.04, 0.04],
                   [0.04, 0.04, 0.04, 0.04, 0.04],
                   [0.04, 0.04, 0.04, 0.04, 0.04],
                   [0.04, 0.04, 0.04, 0.04, 0.04]])
'''
# 5x5 평균 필터 커널 생성  ---②
kernel = np.ones((5,5))/5**2
# 필터 적용             ---③
blured = cv2.filter2D(img, -1, kernel)

# 결과 출력
#cv2.imshow('origin', img)
#cv2.imshow('avrg blur', blured)

cv2_imshow(img)
cv2_imshow(blured)

cv2.waitKey()
cv2.destroyAllWindows()

!python blur_avg_api.py

import cv2
import numpy as np

file_name = '../img/taekwonv1.jpg'
img = cv2.imread(file_name)

# blur() 함수로 블러링  ---①
blur1 = cv2.blur(img, (10,10))
# boxFilter() 함수로 블러링 적용 ---②
blur2 = cv2.boxFilter(img, -1, (10,10))

# 결과 출력
merged = np.hstack( (img, blur1, blur2))
#cv2.imshow('blur', merged)
cv2_imshow(merged)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""### 6.1.3 가우시안 블러링"""

!python blur_gaussian.py

import cv2
import numpy as np

img = cv2.imread('../img/gaussian_noise.jpg')

# 가우시안 커널을 직접 생성해서 블러링  ---①
k1 = np.array([[1, 2, 1],
                   [2, 4, 2],
                   [1, 2, 1]]) *(1/16)
blur1 = cv2.filter2D(img, -1, k1)

# 가우시안 커널을 API로 얻어서 블러링 ---②
k2 = cv2.getGaussianKernel(3, 0)
blur2 = cv2.filter2D(img, -1, k2*k2.T)

# 가우시안 블러 API로 블러링 ---③
blur3 = cv2.GaussianBlur(img, (3, 3), 0)

# 결과 출력
print('k1:', k1)
print('k2:', k2*k2.T)
merged = np.hstack((img, blur1, blur2, blur3))
#cv2.imshow('gaussian blur', merged)
cv2_imshow(merged)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""### 6.1.4 미디언 블러링"""

!python blur_median.py

import cv2
import numpy as np

img = cv2.imread("../img/salt_pepper_noise.jpg")

# 미디언 블러 적용 --- ①
blur = cv2.medianBlur(img, 5)

# 결과 출력
merged = np.hstack((img,blur))
#cv2.imshow('media', merged)
cv2_imshow(merged)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""### 6.1.5 바이레터럴 필터"""

!python blur_bilateral.py

import cv2
import numpy as np

img = cv2.imread("../img/gaussian_noise.jpg")

# 가우시안 필터 적용 ---①
blur1 = cv2.GaussianBlur(img, (5,5), 0)

# 바이레터럴 필터 적용 ---②
blur2 = cv2.bilateralFilter(img, 5, 75, 75)

# 결과 출력
merged = np.hstack((img, blur1, blur2))
#cv2.imshow('bilateral', merged)
cv2_imshow(merged)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""##6.2 경계 검출

### 6.2.1 기본 미분 필터
"""

!python edge_differential.py

import cv2
import numpy as np

img = cv2.imread("../img/sudoku.jpg")

#미분 커널 생성 ---①
gx_kernel = np.array([[ -1, 1]])
gy_kernel = np.array([[ -1],[ 1]])

# 필터 적용 ---②
edge_gx = cv2.filter2D(img, -1, gx_kernel)
edge_gy = cv2.filter2D(img, -1, gy_kernel)
# 결과 출력
merged = np.hstack((img, edge_gx, edge_gy))
#cv2.imshow('edge', merged)
cv2_imshow(merged)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""### 6.2.2 로버츠 교차 필터"""

!python edge_roberts.py

import cv2
import numpy as np

img = cv2.imread("../img/sudoku.jpg")

# 로버츠 커널 생성 ---①
gx_kernel = np.array([[1,0], [0,-1]])
gy_kernel = np.array([[0, 1],[-1,0]])

# 커널 적용 ---②
edge_gx = cv2.filter2D(img, -1, gx_kernel)
edge_gy = cv2.filter2D(img, -1, gy_kernel)

# 결과 출력
merged = np.hstack((img, edge_gx, edge_gy, edge_gx+edge_gy))
#cv2.imshow('roberts cross', merged)
cv2_imshow(merged)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""### 6.2.3 프리윗 필터"""

!python edge_prewitt.py

import cv2
import numpy as np

file_name = "../img/sudoku.jpg"
img = cv2.imread(file_name)

# 프리윗 커널 생성
gx_k = np.array([[-1,0,1], [-1,0,1],[-1,0,1]])
gy_k = np.array([[-1,-1,-1],[0,0,0], [1,1,1]])

# 프리윗 커널 필터 적용
edge_gx = cv2.filter2D(img, -1, gx_k)
edge_gy = cv2.filter2D(img, -1, gy_k)

# 결과 출력
merged = np.hstack((img, edge_gx, edge_gy, edge_gx+edge_gy))
#cv2.imshow('prewitt', merged)
cv2_imshow(merged)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""### 6.2.4 소벨 필터"""

!python edge_sobel.py

import cv2
import numpy as np

img = cv2.imread("../img/sudoku.jpg")

# 소벨 커널을 직접 생성해서 엣지 검출 ---①
## 소벨 커널 생성
gx_k = np.array([[-1,0,1], [-2,0,2],[-1,0,1]])
gy_k = np.array([[-1,-2,-1],[0,0,0], [1,2,1]])
## 소벨 필터 적용
edge_gx = cv2.filter2D(img, -1, gx_k)
edge_gy = cv2.filter2D(img, -1, gy_k)

# 소벨 API를 생성해서 엣지 검출
sobelx = cv2.Sobel(img, -1, 1, 0, ksize=3)
sobely = cv2.Sobel(img, -1, 0, 1, ksize=3)

# 결과 출력
merged1 = np.hstack((img, edge_gx, edge_gy, edge_gx+edge_gy))
merged2 = np.hstack((img, sobelx, sobely, sobelx+sobely))
merged = np.vstack((merged1, merged2))
#cv2.imshow('sobel', merged)
cv2_imshow(merged)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""### 6.2.5 샤르 필터"""

!python edge_scharr.py

import cv2
import numpy as np

img = cv2.imread("../img/sudoku.jpg")

# 샤르 커널을 직접 생성해서 엣지 검출 ---①
gx_k = np.array([[-3,0,3], [-10,0,10],[-3,0,3]])
gy_k = np.array([[-3,-10,-3],[0,0,0], [3,10,3]])
edge_gx = cv2.filter2D(img, -1, gx_k)
edge_gy = cv2.filter2D(img, -1, gy_k)

# 샤르 API로 엣지 검출 ---②
scharrx = cv2.Scharr(img, -1, 1, 0)
scharry = cv2.Scharr(img, -1, 0, 1)

# 결과 출력
merged1 = np.hstack((img, edge_gx, edge_gy))
merged2 = np.hstack((img, scharrx, scharry))
merged = np.vstack((merged1, merged2))
#cv2.imshow('Scharr', merged)
cv2_imshow(merged)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""### 6.2.6 라플라시안 필터"""

!python edge_laplacian.py

import cv2
import numpy as np

img = cv2.imread("../img/sudoku.jpg")

# 라플라시안 필터 적용 ---①
edge = cv2.Laplacian(img, -1)

# 결과 출력
merged = np.hstack((img, edge))
#cv2.imshow('Laplacian', merged)
cv2_imshow(merged)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""### 6.2.7 캐니 엣지"""

!python edge_canny.py

import cv2, time
import numpy as np

img = cv2.imread("../img/sudoku.jpg")

# 케니 엣지 적용
edges = cv2.Canny(img,100,200)

# 결과 출력
#cv2.imshow('Original', img)
#cv2.imshow('Canny', edges)
cv2_imshow(img)
cv2_imshow(edges)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""##6.3 모폴로지

### 6.3.1 침식 연산
"""

!python morph_erode.py

import cv2
import numpy as np

img = cv2.imread('../img/morph_dot.png')

# 구조화 요소 커널, 사각형 (3x3) 생성 ---①
k = cv2.getStructuringElement(cv2.MORPH_RECT, (3,3))
# 침식 연산 적용 ---②
erosion = cv2.erode(img, k)

# 결과 출력
merged = np.hstack((img, erosion))
#cv2.imshow('Erode', merged)
cv2_imshow(merged)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""### 6.3.2 팽창 연산"""

!python morph_dilate.py

import cv2
import numpy as np

img = cv2.imread('../img/morph_hole.png')

# 구조화 요소 커널, 사각형 (3x3) 생성 ---①
k = cv2.getStructuringElement(cv2.MORPH_RECT, (3,3))
# 팽창 연산 적용 ---②
dst = cv2.dilate(img, k)

# 결과 출력
merged = np.hstack((img, dst))
#cv2.imshow('Dilation', merged)
cv2_imshow(merged)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""### 6.3.3 열림과 닫힘, 그밖의 모폴로지 연산"""

!python morph_open_close.py

import cv2
import numpy as np

img1 = cv2.imread('../img/morph_dot.png', cv2.IMREAD_GRAYSCALE)
img2 = cv2.imread('../img/morph_hole.png', cv2.IMREAD_GRAYSCALE)

# 구조화 요소 커널, 사각형 (5x5) 생성 ---①
k = cv2.getStructuringElement(cv2.MORPH_RECT, (5,5))
# 열림 연산 적용 ---②
opening = cv2.morphologyEx(img1, cv2.MORPH_OPEN, k)
# 닫힘 연산 적용 ---③
closing = cv2.morphologyEx(img2, cv2.MORPH_CLOSE, k)

# 결과 출력
merged1 = np.hstack((img1, opening))
merged2 = np.hstack((img2, closing))
merged3 = np.vstack((merged1, merged2))
#cv2.imshow('opening, closing', merged3)
cv2_imshow(merged3)
cv2.waitKey(0)
cv2.destroyAllWindows()

!python morph_gradient.py

import cv2
import numpy as np

img = cv2.imread('../img/morphological.png')

# 구조화 요소 커널, 사각형 (3x3) 생성 ---①
k = cv2.getStructuringElement(cv2.MORPH_RECT, (3,3))
# 열림 연산 적용 ---②
gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, k)

# 결과 출력
merged = np.hstack((img, gradient))
#cv2.imshow('gradient', merged)
cv2_imshow(merged)
cv2.waitKey(0)
cv2.destroyAllWindows()

!python morph_hat.py

import cv2
import numpy as np

img = cv2.imread('../img/moon_gray.jpg')

# 구조화 요소 커널, 사각형 (5x5) 생성 ---①
k = cv2.getStructuringElement(cv2.MORPH_RECT, (9,9))
# 탑햇 연산 적용 ---②
tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, k)
# 블랫햇 연산 적용 ---③
blackhat = cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, k)

# 결과 출력
merged = np.hstack((img, tophat, blackhat))
#cv2.imshow('tophat blackhat', merged)
cv2_imshow(merged)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""##6.4 이미지 피라미드

### 6.4.1 가우시안 피라미드
"""

!python pyramid_gaussian.py

import cv2

img = cv2.imread('../img/girl.jpg')

# 가우시안 이미지 피라미드 축소
smaller = cv2.pyrDown(img) # img x 1/4
# 가우시안 이미지 피라미드 확대
bigger = cv2.pyrUp(img) # img x 4

# 결과 출력
#cv2.imshow('img', img)
#cv2.imshow('pyrDown', smaller)
#cv2.imshow('pyrUp', bigger)

cv2_imshow(img)
cv2_imshow(smaller)
cv2_imshow(bigger)

cv2.waitKey(0)
cv2.destroyAllWindows()

"""### 6.4.2 라플라시안 피라미드"""

!python pyramid_laplacian.py

import cv2
import numpy as np

img = cv2.imread('../img/taekwonv1.jpg')

# 원본 영상을 가우시안 피라미드로 축소
smaller = cv2.pyrDown(img)
# 축소한 영상을 가우시안 피라미드로 확대
bigger = cv2.pyrUp(smaller)

# 원본에서 확대한 영상 빼기
laplacian = cv2.subtract(img, bigger)
# 확대 한 영상에 라플라시안 영상 더해서 복원
restored = bigger + laplacian

# 결과 출력 (원본 영상, 라플라시안, 확대 영상, 복원 영상)
merged = np.hstack((img, laplacian, bigger, restored))
#cv2.imshow('Laplacian Pyramid', merged)
cv2_imshow(merged)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""##6.5 실전 워크숍

### 6.5.1 모자이크 처리 2
"""

!python workshop_mosic2.py

import cv2

ksize = 30              # 블러 처리에 사용할 커널 크기
win_title = 'mosaic'    # 창 제목
img = cv2.imread('../img/taekwonv1.jpg')    # 이미지 읽기

while True:
    x,y,w,h = cv2.selectROI(win_title, img, False) # 관심영역 선택
    if w > 0 and h > 0:         # 폭과 높이가 음수이면 드래그 방향이 옳음
        roi = img[y:y+h, x:x+w]   # 관심영역 지정
        roi = cv2.blur(roi, (ksize, ksize)) # 블러(모자이크) 처리
        img[y:y+h, x:x+w] = roi   # 원본 이미지에 적용
        cv2.imshow(win_title, img)
    else:
        break
cv2.destroyAllWindows()

"""### 6.5.2 스케치 효과 카메라"""

!python workshop_painting_cam.py

import cv2
import numpy as np

# 카메라 장치 연결
cap = cv2.VideoCapture(0)
while cap.isOpened():
    # 프레임 읽기
    ret, frame = cap.read()
    # 속도 향상을 위해 영상크기를 절반으로 축소
    frame = cv2.resize(frame, None, fx=0.5, fy=0.5, \
                        interpolation=cv2.INTER_AREA)
    if cv2.waitKey(1) == 27: # esc키로 종료
        break
    # 그레이 스케일로 변경
    img_gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    # 잡음 제거를 위해 가우시안 플러 필터 적용(라플라시안 필터 적용 전에 필수)
    img_gray = cv2.GaussianBlur(img_gray, (9,9), 0)
    # 라플라시안 필터로 엣지 거출
    edges = cv2.Laplacian(img_gray, -1, None, 5)
    # 스레시홀드로 경계 값 만 남기고 제거하면서 화면 반전(흰 바탕 검은 선)
    ret, sketch = cv2.threshold(edges, 70, 255, cv2.THRESH_BINARY_INV)

    # 경계선 강조를 위해 팽창 연산
    kernel = cv2.getStructuringElement(cv2.MORPH_CROSS, (3,3))
    sketch = cv2.erode(sketch, kernel)
    # 경계선 자연스럽게 하기 위해 미디언 블러 필터 적용
    sketch = cv2.medianBlur(sketch, 5)
    # 그레이 스케일에서 BGR 컬러 스케일로 변경
    img_sketch = cv2.cvtColor(sketch, cv2.COLOR_GRAY2BGR)

    # 컬러 이미지 선명선을 없애기 위해 평균 블러 필터 적용
    img_paint = cv2.blur(frame, (10,10) )
    # 컬러 영상과 스케치 영상과 합성
    img_paint = cv2.bitwise_and(img_paint, img_paint, mask=sketch)

    # 결과 출력
    merged = np.hstack((img_sketch, img_paint))
    #cv2.imshow('Sketch Camera', merged)
    cv2_imshow(merged)

cap.release()
cv2.destroyAllWindows()